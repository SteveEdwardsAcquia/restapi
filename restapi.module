<?php

use Drupal\restapi\Api;
use Drupal\restapi\JsonRequest;
use Drupal\restapi\JsonResponse;
use Drupal\restapi\ResourceConfiguration;
use Drupal\restapi\Exception\ClassNotValidException;
use Drupal\restapi\Exception\AuthClassNotValidException;


/**
 * Implements hook_menu().
 *
 */
function restapi_menu() {

  $resources = restapi_get_resources(TRUE);
  $items = [];

  foreach($resources as $resource) {

    $items[$resource->getPath()] = [
      'page callback'     => 'restapi_page_callback',
      'access callback'   => 'restapi_access_callback',
      'access arguments'  => [$resource],
      'delivery callback' => 'restapi_delivery_callback',
      'type'              => MENU_CALLBACK,
    ];
  }

  $items['admin/config/services/restapi'] = [
    'title'            => 'RestAPI configuration',
    'description'      => 'Configuration settings for the Rest API',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => ['restapi_admin_form'],
    'access arguments' => ['administer site configuration'],
    'file'             => 'restapi.admin.inc',
  ];

  return $items;

}


/**
 * Implements hook_xautoload().
 *
 */
function restapi_xautoload($adapter) {
  if (module_exists('composer_manager')) {
    $dir = composer_manager_vendor_dir() . '/vendor/composer';
    $adapter->absolute()->composerDir($dir);
  }

  if (is_dir(__DIR__ . '/vendor/composer')) {
    $adapter->composerDir('vendor/composer');
  }
}


/**
 * Implements hook_modules_enabled().
 *
 */
function restapi_modules_enabled($modules) {
  restapi_get_resources(TRUE);
}


/**
 * Implements hook_modules_disabled().
 *
 */
function restapi_modules_disabled($modules) {
  restapi_get_resources(TRUE);
}


/**
 * Implements hook_restapi_request().
 *
 */
function restapi_restapi_request($path, ResourceConfiguration $resource, JsonRequest $request) {

  if (variable_get('restapi_debug')) {
    timer_start('restapi-' . $path);
  }

}


/**
 * Implements hook_restapi_response().
 *
 */
function restapi_restapi_response($path, ResourceConfiguration $resource, JsonRequest $request, JsonResponse $response) {

  if (variable_get('restapi_debug')) {
    $timer = timer_stop('restapi-' . $path);
    $response->headers->set('X-Debug-Call-Time', $timer['time'] . 'ms');
  }

}


/**
 * Implements hook_theme_registry_alter().
 *
 * The maintenance page ends up being the output for the default error handler.
 * If we're in an AJAX context then we'll override that to ensure we're
 * returning JSON.
 *
 * Note that this hook will only be fired when the theme is actually called.
 * During an "expected" error as a result of the Drupal\restapi\Api class, this
 * will never be run.
 *
 */
function restapi_theme_registry_alter(&$theme) {

  $request = restapi_get_request();

  if ($request->isJson()) {
    $file = 'restapi.theme.inc';
    $path = drupal_get_path('module', 'restapi');

    $theme['maintenance_page']['function'] = 'theme_restapi_error';
    $theme['maintenance_page']['type'] = 'module';
    $theme['maintenance_page']['theme path'] = $path;
    $theme['maintenance_page']['file'] = $file;
    $theme['maintenance_page']['includes'] = [$path . '/' . $file];

    unset($theme['maintenance_page']['path']);
    unset($theme['maintenance_page']['template']);
  }

}


/**
 * Implements hook_watchdog_alter().
 *
 * WARNING: This hook is only run if Drupal core has been patched too allow for
 * modules to alter the watchdog call before it is processed. If the patch is
 * not applied, this function will never be called.
 *
 * @see patches/bootstrap.inc.patch
 *
 */
function restapi_watchdog_alter(&$log_entry) {
  $request_id = restapi_get_request()->getRequestId();
  $log_entry['message'] = "Request ID: $request_id: " . $log_entry['message'];
}


/**
 * Page callback to handle an API call from the Drupal menu system.
 *
 * @return JsonResponse
 *
 */
function restapi_page_callback() {

  global $user;

  $request = restapi_get_request();
  $api     = new Api($user, $request);

  return $api->call($request->getMethod(), current_path());

}


/**
 * Handles the authentication.
 *
 * @param ResourceConfiguration $resource
 *   The resource that is being accessed, as defined in restapi_get_resources().
 *
 * @return boolean
 *
 */
function restapi_access_callback(ResourceConfiguration $resource) {

  global $user;

  $request = restapi_get_request();
  $auth    = $resource->invokeAuthenticationService($user, $request);

  return $auth->isValid();

}


/**
 * Delivery callback for API responses.
 *
 * @param mixed $response
 *   Generally, a JsonResponse object, or an integer provided by the Drupal menu
 *   system.
 *
 */
function restapi_delivery_callback($response) {

  $request = restapi_get_request();

  // The menu system may return one of these integers.
  if (is_int($response)) {
    switch ($response) {
      case MENU_NOT_FOUND:
        $error   = 'not_found';
        $status  = 404;
        $message = t('The resource "@resource" does not exist.', [
          '@resource' => current_path(),
        ]);
        break;

      // This request failed the access check in hook_menu(). For restapi
      // requests, this is assumed to be an authentication check.
      case MENU_ACCESS_DENIED:
        $error   = 'unauthenticated';
        $status  = 403;
        $message = t('Your credentials could not be verified.');
        break;

      case MENU_SITE_OFFLINE:
        $error   = 'unavailable';
        $status  = 503;
        $message = t('This resource is temporarily offline.');
        break;

      default:
        $error   = 'unknown';
        $status  = 500;
        $message = t('An unknown error occurred. Sorry.');
        break;
    }

    $response = JsonResponse::create([
      'error'   => $error,
      'message' => $message,
    ], $status);

  }
  elseif (!($response instanceof JsonResponse)) {
    watchdog('restapi', '@id: The callback for the path "@path" returned an incorrect response. Expecting an instance of Response, or a Drupal constant (MENU_NOT_FOUND, MENU_ACCESS_DENIED, MENU_SITE_OFFLINE). Received response of type "@type"', [
      '@id'   => $request->getRequestId(),
      '@path' => current_path(),
      '@type' => gettype($response),
    ], WATCHDOG_ERROR);

    $response = JsonResponse::create([
      'error'   => 'unknown',
      'message' => t('This resource is not available.'),
    ], 503);
  }

  $response->headers->set('X-Request-Id', $request->getRequestId());

  // For requests in the browser, we'll try to show the output in a more
  // pleasant way.
  if (!$request->isJson() && in_array('text/html', $request->getAcceptableContentTypes())) {
    return restapi_deliver_html($response);
  }

  $response->send();

  module_invoke_all('exit');

}


/**
 * Delivers the JSON in a HTML wrapper, for easier browser viewing and
 * debugging.
 *
 * @param JsonResponse $response
 *
 */
function restapi_deliver_html(JsonResponse $response) {

  $options = $response->getEncodingOptions();
  $response->setEncodingOptions($options | JSON_PRETTY_PRINT);
  $response->headers->set('Content-Type', 'text/html');

  $headers = $response->headers->getIterator();

  foreach($headers as $header => $values) {
    $value  = implode('; ', $values);
    $header = ucfirst($header);
    print "<strong>$header</strong>: $value<br />\n";
  }

  print "<pre>";
  $response->send();
  print "</pre>";

  module_invoke_all('exit');

}


/**
 * Returns an object representing the current page request.
 *
 * @return JsonRequest
 *
 */
function restapi_get_request() {

  static $request = NULL;

  if (!$request) {
    $request = JsonRequest::createFromGlobals();
  }

  return $request;

}


/**
 * Returns a single resource, depending on the path provided.
 *
 * @param string $path
 *   The path for the resource to return.
 *
 * @return ResourceConfiguration
 *   Returns a ResourceConfiguration object, or FALSE If the resource does not
 *   exist.
 *
 */
function restapi_get_resource($path) {

  $resources = restapi_get_resources();
  $resource  = NULL;

  foreach($resources as $resource) {
    if ($resource->matchesPath($path)) {
      return $resource;
    }
  }

  return FALSE;

}


/**
 * Returns all resources implemented by other modules.
 *
 * @param boolean $refresh
 *   Determines whether the cached copy (if it exists) of the resources should
 *   be ignored (default: FALSE).
 *
 * @return ResourceConfiguration[]
 *
 */
function restapi_get_resources($refresh = FALSE) {

  if (!$refresh && $cache = cache_get('restapi_resources')) {
    return $cache->data;
  }

  $modules      = module_implements('restapi_resources');
  $items        = [];
  $default_auth = variable_get('restapi_default_auth_class') ?: 'Drupal\restapi\Auth\DrupalAuthenticationService';
  $url_prefix   = variable_get('restapi_url_prefix');

  foreach($modules as $module) {

    $resources = module_invoke($module, 'restapi_resources');

    foreach($resources as $path => $resource) {
      $class = isset($resource['class']) ? $resource['class'] : 'ClassNotDefined';
      $auth  = isset($resource['auth']) ? $resource['auth'] : $default_auth;

      // Ensure our resource definitions are valid, and skip registering them
      // if they are not.
      try {
        $items[] = new ResourceConfiguration($path, $module, $class, $auth, $url_prefix);
      }
      catch (ClassNotValidException $e) {
        watchdog('restapi', 'The resource "@resource" in the module "@module" is not valid because the class "@class" does not exist.', [
          '@class'    => $class,
          '@resource' => $path,
          '@module'   => $module,
        ], WATCHDOG_WARNING);
        continue;
      }
      catch (AuthClassNotValidException $e) {
        watchdog('restapi', 'The resource "@resource" in the module "@module" is not valid because the authentication class "@auth" does not exist.', [
          '@auth'     => $auth,
          '@resource' => $path,
          '@module'   => $module,
        ], WATCHDOG_WARNING);
        continue;
      }
    }
  }

  cache_set('restapi_resources', $items);

  return $items;

}


/**
 * Helper function to makes an internal request to a resource.
 *
 * Internal requests skip the HTTP overhead of the resource, and bypass the
 * authentication check. The resource may still implement an access check which
 * will be respected.
 *
 * Note that the method and data provided will override the method or data set
 * in the optional request object.
 *
 * @param string $method
 *   The HTTP method to call for the resource. This overrides the method set in
 *   the optional request object.
 * @param string $path
 *   The path representing the resource to call.
 * @param array $data
 *   An array of data to provide the resource. This overrides any data set in
 *   the optional request object.
 * @param \StdClass $user
 *   (Optional) The Drupal user to call this resource as. Defaults to the
 *   current user.
 * @param JsonRequest $request
 *   (Optional) The request to use to set the context for the resource. Defaults
 *   to the current request context.
 *
 * @return JsonResponse
 *
 */
function restapi_execute_resource($method, $path, array $data = [], \StdClass $user = NULL, JsonRequest $request = NULL) {

  $request = $request ?: restapi_get_request();
  $user    = $user ?: $GLOBALS['user'];
  $api     = new Api($user, $request);

  return $api->call($method, $path, $data);

}